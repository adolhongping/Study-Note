# C++学习笔记

### 1、双冒号、using和namespace

* **namespace**主要用来解决命名冲突的问题
  * 必须在全局作用域下声明
  * 命名空间下可以放函数，变量、结构体和类
  * 命名空间可以嵌套命名空间
  * 命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可
  * 命名空间可以起别名

* **双冒号**::作用域运算符
  * 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
  * 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
  * 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

* **using**分为using声明和using编译指令
  * `using std::cout; //声明`
  * `using namespace std; //编译指令`
  * 尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性
  * 一般来说，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称；**using声明使特定的标示符可用，using编译指令使整个名称空间可用。**

### 2、C++相对于C做了哪些增强

​			1、 全局变量的检测增强

​			2、 函数的检测增强

​					参数类型检测、返回值检测、函数调用参数检测增强

​			3、类型转换检测增强

​			4、struct增强

​			5、bool类型增强

​			6、3目运算符增强，c语言中返回的是值，c++中返回的是变量

​			7、const增强，

​					在c中，const修饰的变量是伪常量，编译器会分配内存;c中const默认外部链接

​					在c++中，const不会分配内存，其存储在符号表中，即键值对；c++中const默认内部链接

​			8、const内存分配情况

​					取地址时会分配临时的内存

​					exterm，编译器也会给const分配内存

​					用普通变量初始化const变量时

​					自定义数据类型，加const也会分配内存；

### 3、引用

#### 1、基本语法

`Type &别名 = 原名；`

引用必须初始化/初始化后不可以被修改

#### 2、引用的注意事项

 引用的注意事项
 1.必须引用合法的n内存空间 `int &a=10;  //不合法`
 2.不要返回局部变量的引用

``int& dowork2()` 
 `{   
int a = 10;`
return a;

}`

3.如果函数的返回值是引用，则这个函数k可以作为左值；

#### 3、引用的本质

在c++内部实现一个指针常量

`Type& ref = val;	//Type* const ref =&val;`

#### 4、指针的引用

一级指针引用可以代替二级指针；

#### 5、常量的引用

修饰形参为只读

const int &a=10;会分配内存

### 4、类

1、类和对象的关系

类是对对象的抽象

对象是对类的实现

### 5、内联函数

#### 1、宏定义有哪些缺陷

- 宏定义都是直接嵌入代码中的，所以代码可能更多一点
- 嵌套定义过多会影响程序的可读性，而且容易出错
- 对于带参数的宏而言，由于是直接转换，并不会检查参数是否合法，存在安全隐患，预编译语句仅仅是单独的值替换，缺乏类型检测机制。
- 宏不是函数、宏不是语句、宏并不是类型定义

#### 1、内联函数

- 解决类宏缺陷问题
- 给编译器的一个建议，加上关键字，编译器不一定按照内联处理
- 不加关键字inline,也许编译器会偷摸加上inline

#### 2、内联函数的注意事项

- `inline void func();		//内联函数的声明`
- `inline void func(){	};	// 如果函数实现的时候，没有加inline,那么这个函数依旧不算内联函数`
- `类内部的成员函数，默认前面会加inline;`

### 6、C++语言的封装

1. 将属性和行为作为一个整体来表示生活中具体的事物
2. 有访问权限

- struct和class是一个意思，唯一的不同是默认权限，struct成员的默认权限是public,class的默认权限是private
- public：		类内 类外都可以访问
- protected: 	类内，该类的子类可以访问 在类外不可以访问到
- private			类内可以访问，类外不可以访问（子类不可以访问）  

3. 建议将所有成员变量设为私有，通过set和get方法来修改成员变量

### 7、对象的构造和析构

#### 1、什么是构造函数和析构函数

代码链接：https://blog.csdn.net/weixin_45233461/article/details/106089555

- 对象的初始化和清理
- 如果程序员没有提供构造函数和析构函数，系统会默认提供，空实现！

#### 2、构造函数

- 与类名相同
- 没有返回值
- 不写void
- 可以发生重载（可以有参数）
- 构造函数由编译器自动调用，而不是手动，而且只会调用一次

#### 3、析构函数

- 与类名相同，类名前加“~”
- 也没有返回值
- 不写void,不可以有参数（不能发生重载）

- 自动调用，只会调用一次

#### 4、构造函数的分类和调用

代码连接：https://blog.csdn.net/weixin_45233461/article/details/106235142

- 按照参数分类
  - 无参构造（默认构造）
  - 有参构造
- 按照类型分类
  - 普通构造函数
  - 拷贝构造函数
- Person(1):匿名对象
  - 不能用拷贝构造函数初始化匿名对象

#### 5、拷贝构造函数调用时机

代码连接：https://blog.csdn.net/weixin_45233461/article/details/106236486

1. 用已经创建好的对象初始化新的对象
2. 以值传递的方式给函数参数传值
3. 以值的方式返回局部对象
4. Release模式下会对代码进行优化（VS 中！)

#### 6、构造函数的调用规则

系统默认给一个类提供三个函数 默认函数、拷贝函数、析构函数

1. 当我们提供了有参构造函数，那么系统就不会再给我们提供默认构造函数了，但是系统会提供默人拷贝构造函数，进行简单的值拷贝
2. 当提供了拷贝构造函数，系统将不会提供其他构造函数

#### 7、深拷贝和浅拷贝

代码链接：https://blog.csdn.net/weixin_45233461/article/details/106257127

**浅拷贝**

系统提供的默认拷贝构造，会进行简单的值拷贝

如果属性里面有指向堆区空间的数据，那么简单的值拷贝会导致重复的释放内存的异常

**深拷贝**

解决上述问题，需要我们自己提供拷贝构造函数，进行深拷贝

### 8、初始化列表语法

代码链接：https://blog.csdn.net/weixin_45233461/article/details/106268605

在构造函数后面+ ：属性（参数、值），属性（参数、值）......

## 关键字

### 1、const关键字

https://www.runoob.com/w3cnote/cpp-const-keyword.html

### 2、malloc关键字

https://www.runoob.com/cprogramming/c-function-malloc.html

### 3、strlen关键字

https://www.runoob.com/cprogramming/c-function-strlen.html

strlen(name)+1；+1的目的是包含结束符！



## 学习问题总结：

### 1、C++11编译问题：warning: ISO C++11 does not allow conversion from string literal to 'char *'

https://blog.csdn.net/wangzhezhilu001/article/details/104216989?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase



​	

​					